[ { "title": "requirements.txtとは", "url": "/posts/requirements.txt/", "categories": "python, pip, requirements.txt", "tags": "requirements.txt", "date": "2022-05-08 00:00:00 +0900", "snippet": " requirements.txtとは 他の人とプロジェットを共有したり、本番環境に反映させるときに、プロジェクトに必要な外部パッケージを反映させる必要がある。 この外部パッケージの名前やバージョンがあるファイルが requirements.txt　です。 一言でいうと、対象のプロジェクトにpip installする必要があるパッケージリストを記載しているファイルです。requirements.txtの使用方法 自分のプロジェクトにインストるされているパッケージリストを見る $ pip freeze requirements.txtを生成する方法 $ pip freeze &amp;gt; requirements.txt 下記のようにrequirements.txtファイルが生成され、パッケージの名前とバージョンが入っていることが確認できる。 生成したrequirements.txtにあるパッケージリストを環境にインストるする方法 対象のプロジェクトでターミナルに下記のコマンドを入力する。 $ pip install -r requirements.txt 最後に開発をしている際、パッケージのバージョンが違うだけでエラーが出ることが多いです。requirements.txtで管理することで効率的に開発することができると思いました。" }, { "title": "GithubのRepositoryを合体する", "url": "/posts/GIthub-Repository-Merge/", "categories": "Gitshub, Git", "tags": "Git, Github, repository", "date": "2022-03-22 00:00:00 +0900", "snippet": "GitHub repositoryを合体する色んな小さなプロジェクトのRepositoryがどんどん増えていて、複数のRepositoryを一つにまとめたいと思いました。新しいRepositoryを作成し、作成したファイルをCommitする方法でもできますが、今まで作成したCommit履歴を残したかったので合体する方法を紹介します。今回 project1-frontend Repository、project1-backend RepositoryのをNewProject Repositoryへ移動します。 新しい（移動したい）Repositoryを生成する（NewProject Repository） 生成したRepositoryをlocalにcloneする $ git clone [Repository] $ git clone https://github.com/jcjfgnl9205/NewProject.git どんな内容でもコミットするREADME.mdファイルを作成し、下記のコマンドでCommitするCommitしないと、subtreeする時エラーになりました。。 $ git add .$ git commit -m &quot;first commit&quot; $ git push origin main RepositoryにREADME.mdが生成される Repositoryを合体する project1-backend Repositoryを移動する $ git subtree add --prefix=[生成するディレクトリ名] [移動したいRepository] [Branch名] -$ git subtree add --prefix=backend https://github.com/jcjfgnl9205/project1-backend.git main $ git push origin main project1-backend Repositoryのファイルがbackendフォルダの中にcommitされるし、commit履歴が残ることが確認できます。 project1-frontend Repositoryを移動する $ git subtree add --prefix=[生成するディレクトリ名] [移動したいRepository] [Branch名] -$ git subtree add --prefix=frontend https://github.com/jcjfgnl9205/project1--frontend.git main $ git push origin main project1-frontend Repositoryのファイルがfrontendフォルダの中にcommitされるし、commit履歴が残ることが確認できます。 ※合体後、既存のproject1-backend Repositoryとproject1-frontend Repositoryのrepositoryは削除してもcommit履歴は残る以上" }, { "title": "REST API", "url": "/posts/REST-API/", "categories": "RESTAPI", "tags": "RESTAPI", "date": "2022-02-23 00:00:00 +0900", "snippet": "API(application programming interface)とは コンピュータまたはアプリケーションが相互に通信する方法を説明する一連の定義済みルールAPIの仕組み クライアントアプリケーションは、要求とも呼ばれる情報を取得するためにAPIコールを開始する 有効な要求を受信すると、APIは外部プログラムまたはWebサーバにコールを発信する サーバは、要求された情報を含む応答をAPIに送信する APIはデータを最初の要求アプリケーションに転送するREST(Representational State Transfer)とは Web上のコンピュータシステム間で標準を提供し、システム間の通信を容易にするアーキテクチャスタイルRESTの設計原則 統一されたインターフェース 同じリソースに対するすべてのAPIリクエストは、リクエストの送信元に関係なく、同じように見える必要がある REST APIは、ユーザーの名前や電子メール・アドレスなど、同じデータが1つのURIだけに属するようにする。 クライアントが必要とする可能性のあるすべての情報が含まれている必要がある クライアントとサーバーの分離 REST APIの設計では、クライアントとサーバーは互いに完全に独立している必要がある クライアントは要求するリソースのURIのみを知っていればいい、サーバーと対話することはない サーバーは要求されたデータをHTTPを介して渡すのみで、クライアントを変更することはない ステートレス(Stateless) 各リクエストには、その処理に必要なすべての情報を含める必要がある(サーバー側のセッションは不要) サーバーは、クライアントのリクエストに関連するデータの保存を許可されていない キャッシュ可能性 キャッシュが許可されている場合はクライアント側またはサーバー側でリソースのキャッシュが可能である必要がある サーバーの応答には配信するリソースのキャッシュが許可されているかどうかに関する情報も含まれている必要がある サーバー側のスケーラビリティーが向上すると同時に、クライアント側のパフォーマンスも改善される 階層化されたシステム・アーキテクチャー REST APIでは、呼び出しと応答は異なる階層を通過する クライアントとサーバーが互いに直接接続していると想定してしまうのはだめ(通信ループにはさまざまな中間システムが存在する可能性がある) REST APIでは、クライアントとサーバーのいずれも、エンド・アプリケーションと中間システムのどちらと通信しているのかを判別できないように設計する必要がある コードオンデマンド(オプション) 通常、静的リソースを送信するが、場合によっては応答に実行可能コード（Javaアプレットなど）を含めることもできる（この場合、コードは必ずオンデマンドで実行する必要がある） REST APIの例掲示板を作成して、リストを表示、更新、削除する時のURLを作成してみるRESTAPI修正前 掲示板を新規作成する：/createBoard 掲示板の一覧を表示する：/viewBoards no=1の掲示板の詳細を表示する：/getBoard/1 no=1の掲示板を削除する：/deleteBoard/1 no=1の掲示板を更新する：/updateBoard/1 作成日が７月のリストを表示する：/findBoardsFromThisMonth 上記ように作成すると見づらいと思いますので下記条件を使用して作成する URLで動詞は使用しない HTTP methodsを利用してインタラクションする（GET, POST, PUT, DELETE, PATCH） Query Parameterを利用するRESTAPI修正後 掲示板を新規作成する：POST /Board 掲示板の一覧を表示する：GET /Boards no=1の掲示板の詳細を表示する：GET /Board/1 no=1の掲示板を削除する：DELETE /Board/1 no=1の掲示板を更新する：PUT /Board/1 作成日が７月のリストを表示する：/boards?release_date=7 reference https://www.ibm.com/jp-ja/cloud/learn/rest-apis https://www.ibm.com/cloud/learn/api" }, { "title": "Web Storageとは？", "url": "/posts/Web-Storage/", "categories": "WebStorage, Cookie", "tags": "Session Storage, Local Storage, Cookie", "date": "2022-02-20 00:00:00 +0900", "snippet": "Web StorageWeb Storageとは、HTML5より使える機能として、データをサーバーではなくクライアントウェブブラウザに保存できる機能として、Cookieと似ている？Web Storageは key, valueでデータを保存して、key値でデータが取得できる。Local Strogae(永久的に保存する)とSession Storage(一時的に保存する)がそれぞれあるので環境によって使用する。Web Storageは、Cookieと同様でサイトのドメインの中でしか使用できない。Web Storage VS CookieCookieとWeb Storageは全てブラウザにデータを保存しますが、Cookieのディメリットの部分を保安できる Cookieはいつもサーバーにデータを送信するウェブサイトでCookieを設定すると、全てのRequestはCookie情報を含めてサーバーに送信するWeb Storageはデータが保存されるだけで送信されないのでネットワークのトラフィックを軽減することができる Web Storageにもっと多いデータを保存することができる1つのサイトに保存できるCookieは最大20個、容量は4KBが、Web Storageは5MBまで保存することができる オブジェクト情報も保存できるWeb Storageには、String型以外にもオプジェットも保存することができるので開発するときにも便利だと思う Web Storageは永久的に保存することができるCookieの場合、満了日があるのでいつかは削除される。満了日を設定しないとSessionCookieになる。もし、永久的に使いたいCookieがあると満了日を長く設定して解決する方法もあります。(Persistent Cookie)しかし、Web Storageは満了日がないため、保存したデータを永久的に保存することができる ※Session Cookieとは？サーバーに対するSessionが終了した時点で（通常、ブラウザを終了した時点で）破棄される ※Persistent Cookieとは？各Cookieに指定された期間の間、または装置においてCookieを手動で削除するまで装置に残っている Web Storageの種類 Local Storage window.localStorageオブジェクト ブラウザーを閉じても保存されるデータ、明示的に削除されない限り永久的に保存される ドメイン別に生成され、他のドメインのLocal Storageにはアクセスできない 異なるブラウザタブでも同一ドメインであれば同一のLocal Storageを使用する 持続的に必要な情報を保存する場合良い(ex. 自動ログインなど) Session Storage window.sessionStorageオブジェクト ページセッションは、ブラウザが開いている限りリフレッシュとページの復旧を経ても残っている ページを新しいタブやウィンドウで開くと, Session Cookieの動作とは異なり、最上位のブラウジング文脈の値を持つ新しいSessionを生成する 同じURLを多数のタブ/ウィンドウで開くと、それぞれのタブ/ウィンドウに対して新しいSession Storageが生成される タブ/ウィンドウを閉じると、Sessionが終わり、Session Storageの中のオブジェクトを初期化する 異なるSession Storageは、互いに影響を与えず、独立的に動作する しばらく必要な情報を保存するのに良い. (ex. 入力したォームの保存、ログインなど) 参考LocalStorageSessionStorage以上" } ]
